/**
 * POP API
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { ModifiedResourceSchema } from '../model/modified-resource-schema';
// @ts-ignore
import { PaginatedPatientCase } from '../model/paginated-patient-case';
// @ts-ignore
import { PatientCase } from '../model/patient-case';
// @ts-ignore
import { PatientCaseBundle } from '../model/patient-case-bundle';
// @ts-ignore
import { PatientCaseBundleCreate } from '../model/patient-case-bundle-create';
// @ts-ignore
import { PatientCaseCreate } from '../model/patient-case-create';
// @ts-ignore
import { PatientCaseDataCompletionStatusSchema } from '../model/patient-case-data-completion-status-schema';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import {
    PatientCasesServiceInterface,
    CreatePatientCaseRequestParams,
    CreatePatientCaseBundleByIdRequestParams,
    CreatePatientCaseDataCompletionRequestParams,
    DeletePatientCaseByIdRequestParams,
    DeletePatientCaseDataCompletionRequestParams,
    GetPatientCaseBundleByIdRequestParams,
    GetPatientCaseByIdRequestParams,
    GetPatientCaseByPseudoidentifierRequestParams,
    GetPatientCaseDataCompletionStatusRequestParams,
    GetPatientCasesRequestParams,
    UpdatePatientCaseByIdRequestParams
} from './patient-cases.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class PatientCasesService implements PatientCasesServiceInterface {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;
            if (firstBasePath != undefined) {
                basePath = firstBasePath;
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Create Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResourceSchema>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResourceSchema>>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResourceSchema>>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const patientCaseCreate = requestParameters?.patientCaseCreate;
        if (patientCaseCreate === null || patientCaseCreate === undefined) {
            throw new Error('Required parameter patientCaseCreate was null or undefined when calling createPatientCase.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases`;
        return this.httpClient.request<ModifiedResourceSchema>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: patientCaseCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Patient Case Bundle
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPatientCaseBundleById(requestParameters: CreatePatientCaseBundleByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResourceSchema>;
    public createPatientCaseBundleById(requestParameters: CreatePatientCaseBundleByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResourceSchema>>;
    public createPatientCaseBundleById(requestParameters: CreatePatientCaseBundleByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResourceSchema>>;
    public createPatientCaseBundleById(requestParameters: CreatePatientCaseBundleByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const patientCaseBundleCreate = requestParameters?.patientCaseBundleCreate;
        if (patientCaseBundleCreate === null || patientCaseBundleCreate === undefined) {
            throw new Error('Required parameter patientCaseBundleCreate was null or undefined when calling createPatientCaseBundleById.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/bundle`;
        return this.httpClient.request<ModifiedResourceSchema>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: patientCaseBundleCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Patient Case Data Completion
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResourceSchema>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResourceSchema>>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResourceSchema>>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling createPatientCaseDataCompletion.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling createPatientCaseDataCompletion.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResourceSchema>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling deletePatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Patient Case Data Completion
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling deletePatientCaseDataCompletion.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling deletePatientCaseDataCompletion.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case Bundle By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseBundleById(requestParameters: GetPatientCaseBundleByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCaseBundle>;
    public getPatientCaseBundleById(requestParameters: GetPatientCaseBundleByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCaseBundle>>;
    public getPatientCaseBundleById(requestParameters: GetPatientCaseBundleByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCaseBundle>>;
    public getPatientCaseBundleById(requestParameters: GetPatientCaseBundleByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseBundleById.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/bundle/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCaseBundle>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCase>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCase>>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCase>>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case By Pseudoidentifier
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCase>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCase>>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCase>>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const pseudoidentifier = requestParameters?.pseudoidentifier;
        if (pseudoidentifier === null || pseudoidentifier === undefined) {
            throw new Error('Required parameter pseudoidentifier was null or undefined when calling getPatientCaseByPseudoidentifier.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/pseudo/${this.configuration.encodeParam({name: "pseudoidentifier", value: pseudoidentifier, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case Data Completion Status
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCaseDataCompletionStatusSchema>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCaseDataCompletionStatusSchema>>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCaseDataCompletionStatusSchema>>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseDataCompletionStatus.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getPatientCaseDataCompletionStatus.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCaseDataCompletionStatusSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Patient Cases Matching The Query
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedPatientCase>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedPatientCase>>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedPatientCase>>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const ageLessThan = requestParameters?.ageLessThan;
        const ageLessThanOrEqual = requestParameters?.ageLessThanOrEqual;
        const ageGreaterThan = requestParameters?.ageGreaterThan;
        const ageGreaterThanOrEqual = requestParameters?.ageGreaterThanOrEqual;
        const ageEqual = requestParameters?.ageEqual;
        const ageNotEqual = requestParameters?.ageNotEqual;
        const ageBetween = requestParameters?.ageBetween;
        const ageNotBetween = requestParameters?.ageNotBetween;
        const overallSurvivalNotExists = requestParameters?.overallSurvivalNotExists;
        const overallSurvivalExists = requestParameters?.overallSurvivalExists;
        const overallSurvivalLessThan = requestParameters?.overallSurvivalLessThan;
        const overallSurvivalLessThanOrEqual = requestParameters?.overallSurvivalLessThanOrEqual;
        const overallSurvivalGreaterThan = requestParameters?.overallSurvivalGreaterThan;
        const overallSurvivalGreaterThanOrEqual = requestParameters?.overallSurvivalGreaterThanOrEqual;
        const overallSurvivalEqual = requestParameters?.overallSurvivalEqual;
        const overallSurvivalNotEqual = requestParameters?.overallSurvivalNotEqual;
        const overallSurvivalBetween = requestParameters?.overallSurvivalBetween;
        const overallSurvivalNotBetween = requestParameters?.overallSurvivalNotBetween;
        const dataCompletionRateLessThan = requestParameters?.dataCompletionRateLessThan;
        const dataCompletionRateLessThanOrEqual = requestParameters?.dataCompletionRateLessThanOrEqual;
        const dataCompletionRateGreaterThan = requestParameters?.dataCompletionRateGreaterThan;
        const dataCompletionRateGreaterThanOrEqual = requestParameters?.dataCompletionRateGreaterThanOrEqual;
        const dataCompletionRateEqual = requestParameters?.dataCompletionRateEqual;
        const dataCompletionRateNotEqual = requestParameters?.dataCompletionRateNotEqual;
        const dataCompletionRateBetween = requestParameters?.dataCompletionRateBetween;
        const dataCompletionRateNotBetween = requestParameters?.dataCompletionRateNotBetween;
        const id = requestParameters?.id;
        const idNot = requestParameters?.idNot;
        const idContains = requestParameters?.idContains;
        const idNotContains = requestParameters?.idNotContains;
        const idBeginsWith = requestParameters?.idBeginsWith;
        const idNotBeginsWith = requestParameters?.idNotBeginsWith;
        const idEndsWith = requestParameters?.idEndsWith;
        const idNotEndsWith = requestParameters?.idNotEndsWith;
        const pseudoidentifier = requestParameters?.pseudoidentifier;
        const pseudoidentifierNot = requestParameters?.pseudoidentifierNot;
        const pseudoidentifierContains = requestParameters?.pseudoidentifierContains;
        const pseudoidentifierNotContains = requestParameters?.pseudoidentifierNotContains;
        const pseudoidentifierBeginsWith = requestParameters?.pseudoidentifierBeginsWith;
        const pseudoidentifierNotBeginsWith = requestParameters?.pseudoidentifierNotBeginsWith;
        const pseudoidentifierEndsWith = requestParameters?.pseudoidentifierEndsWith;
        const pseudoidentifierNotEndsWith = requestParameters?.pseudoidentifierNotEndsWith;
        const clinicalCenter = requestParameters?.clinicalCenter;
        const clinicalCenterNot = requestParameters?.clinicalCenterNot;
        const clinicalCenterContains = requestParameters?.clinicalCenterContains;
        const clinicalCenterNotContains = requestParameters?.clinicalCenterNotContains;
        const clinicalCenterBeginsWith = requestParameters?.clinicalCenterBeginsWith;
        const clinicalCenterNotBeginsWith = requestParameters?.clinicalCenterNotBeginsWith;
        const clinicalCenterEndsWith = requestParameters?.clinicalCenterEndsWith;
        const clinicalCenterNotEndsWith = requestParameters?.clinicalCenterNotEndsWith;
        const clinicalIdentifier = requestParameters?.clinicalIdentifier;
        const clinicalIdentifierNot = requestParameters?.clinicalIdentifierNot;
        const clinicalIdentifierContains = requestParameters?.clinicalIdentifierContains;
        const clinicalIdentifierNotContains = requestParameters?.clinicalIdentifierNotContains;
        const clinicalIdentifierBeginsWith = requestParameters?.clinicalIdentifierBeginsWith;
        const clinicalIdentifierNotBeginsWith = requestParameters?.clinicalIdentifierNotBeginsWith;
        const clinicalIdentifierEndsWith = requestParameters?.clinicalIdentifierEndsWith;
        const clinicalIdentifierNotEndsWith = requestParameters?.clinicalIdentifierNotEndsWith;
        const consentStatus = requestParameters?.consentStatus;
        const consentStatusNot = requestParameters?.consentStatusNot;
        const consentStatusAnyOf = requestParameters?.consentStatusAnyOf;
        const gender = requestParameters?.gender;
        const genderNot = requestParameters?.genderNot;
        const genderAnyOf = requestParameters?.genderAnyOf;
        const genderNotAnyOf = requestParameters?.genderNotAnyOf;
        const genderDescendantsOf = requestParameters?.genderDescendantsOf;
        const raceNotExists = requestParameters?.raceNotExists;
        const raceExists = requestParameters?.raceExists;
        const race = requestParameters?.race;
        const raceNot = requestParameters?.raceNot;
        const raceAnyOf = requestParameters?.raceAnyOf;
        const raceNotAnyOf = requestParameters?.raceNotAnyOf;
        const raceDescendantsOf = requestParameters?.raceDescendantsOf;
        const sexAtBirthNotExists = requestParameters?.sexAtBirthNotExists;
        const sexAtBirthExists = requestParameters?.sexAtBirthExists;
        const sexAtBirth = requestParameters?.sexAtBirth;
        const sexAtBirthNot = requestParameters?.sexAtBirthNot;
        const sexAtBirthAnyOf = requestParameters?.sexAtBirthAnyOf;
        const sexAtBirthNotAnyOf = requestParameters?.sexAtBirthNotAnyOf;
        const sexAtBirthDescendantsOf = requestParameters?.sexAtBirthDescendantsOf;
        const genderIdentityNotExists = requestParameters?.genderIdentityNotExists;
        const genderIdentityExists = requestParameters?.genderIdentityExists;
        const genderIdentity = requestParameters?.genderIdentity;
        const genderIdentityNot = requestParameters?.genderIdentityNot;
        const genderIdentityAnyOf = requestParameters?.genderIdentityAnyOf;
        const genderIdentityNotAnyOf = requestParameters?.genderIdentityNotAnyOf;
        const genderIdentityDescendantsOf = requestParameters?.genderIdentityDescendantsOf;
        const dateOfBirthBefore = requestParameters?.dateOfBirthBefore;
        const dateOfBirthAfter = requestParameters?.dateOfBirthAfter;
        const dateOfBirthOnOrBefore = requestParameters?.dateOfBirthOnOrBefore;
        const dateOfBirthOnOrAfter = requestParameters?.dateOfBirthOnOrAfter;
        const dateOfBirthOn = requestParameters?.dateOfBirthOn;
        const dateOfBirthNotOn = requestParameters?.dateOfBirthNotOn;
        const dateOfBirthBetween = requestParameters?.dateOfBirthBetween;
        const dateOfBirthNotBetween = requestParameters?.dateOfBirthNotBetween;
        const isDeceased = requestParameters?.isDeceased;
        const dateOfDeathNotExists = requestParameters?.dateOfDeathNotExists;
        const dateOfDeathExists = requestParameters?.dateOfDeathExists;
        const dateOfDeathBefore = requestParameters?.dateOfDeathBefore;
        const dateOfDeathAfter = requestParameters?.dateOfDeathAfter;
        const dateOfDeathOnOrBefore = requestParameters?.dateOfDeathOnOrBefore;
        const dateOfDeathOnOrAfter = requestParameters?.dateOfDeathOnOrAfter;
        const dateOfDeathOn = requestParameters?.dateOfDeathOn;
        const dateOfDeathNotOn = requestParameters?.dateOfDeathNotOn;
        const dateOfDeathBetween = requestParameters?.dateOfDeathBetween;
        const dateOfDeathNotBetween = requestParameters?.dateOfDeathNotBetween;
        const causeOfDeathNotExists = requestParameters?.causeOfDeathNotExists;
        const causeOfDeathExists = requestParameters?.causeOfDeathExists;
        const causeOfDeath = requestParameters?.causeOfDeath;
        const causeOfDeathNot = requestParameters?.causeOfDeathNot;
        const causeOfDeathAnyOf = requestParameters?.causeOfDeathAnyOf;
        const causeOfDeathNotAnyOf = requestParameters?.causeOfDeathNotAnyOf;
        const causeOfDeathDescendantsOf = requestParameters?.causeOfDeathDescendantsOf;
        const manager = requestParameters?.manager;
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ageLessThan !== undefined && ageLessThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageLessThan, 'age.lessThan');
        }
        if (ageLessThanOrEqual !== undefined && ageLessThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageLessThanOrEqual, 'age.lessThanOrEqual');
        }
        if (ageGreaterThan !== undefined && ageGreaterThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageGreaterThan, 'age.greaterThan');
        }
        if (ageGreaterThanOrEqual !== undefined && ageGreaterThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageGreaterThanOrEqual, 'age.greaterThanOrEqual');
        }
        if (ageEqual !== undefined && ageEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageEqual, 'age.equal');
        }
        if (ageNotEqual !== undefined && ageNotEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ageNotEqual, 'age.not.equal');
        }
        if (ageBetween) {
            ageBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'age.between');
            })
        }
        if (ageNotBetween) {
            ageNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'age.not.between');
            })
        }
        if (overallSurvivalNotExists !== undefined && overallSurvivalNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalNotExists, 'overallSurvival.not.exists');
        }
        if (overallSurvivalExists !== undefined && overallSurvivalExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalExists, 'overallSurvival.exists');
        }
        if (overallSurvivalLessThan !== undefined && overallSurvivalLessThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalLessThan, 'overallSurvival.lessThan');
        }
        if (overallSurvivalLessThanOrEqual !== undefined && overallSurvivalLessThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalLessThanOrEqual, 'overallSurvival.lessThanOrEqual');
        }
        if (overallSurvivalGreaterThan !== undefined && overallSurvivalGreaterThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalGreaterThan, 'overallSurvival.greaterThan');
        }
        if (overallSurvivalGreaterThanOrEqual !== undefined && overallSurvivalGreaterThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalGreaterThanOrEqual, 'overallSurvival.greaterThanOrEqual');
        }
        if (overallSurvivalEqual !== undefined && overallSurvivalEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalEqual, 'overallSurvival.equal');
        }
        if (overallSurvivalNotEqual !== undefined && overallSurvivalNotEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>overallSurvivalNotEqual, 'overallSurvival.not.equal');
        }
        if (overallSurvivalBetween) {
            overallSurvivalBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'overallSurvival.between');
            })
        }
        if (overallSurvivalNotBetween) {
            overallSurvivalNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'overallSurvival.not.between');
            })
        }
        if (dataCompletionRateLessThan !== undefined && dataCompletionRateLessThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateLessThan, 'dataCompletionRate.lessThan');
        }
        if (dataCompletionRateLessThanOrEqual !== undefined && dataCompletionRateLessThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateLessThanOrEqual, 'dataCompletionRate.lessThanOrEqual');
        }
        if (dataCompletionRateGreaterThan !== undefined && dataCompletionRateGreaterThan !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateGreaterThan, 'dataCompletionRate.greaterThan');
        }
        if (dataCompletionRateGreaterThanOrEqual !== undefined && dataCompletionRateGreaterThanOrEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateGreaterThanOrEqual, 'dataCompletionRate.greaterThanOrEqual');
        }
        if (dataCompletionRateEqual !== undefined && dataCompletionRateEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateEqual, 'dataCompletionRate.equal');
        }
        if (dataCompletionRateNotEqual !== undefined && dataCompletionRateNotEqual !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dataCompletionRateNotEqual, 'dataCompletionRate.not.equal');
        }
        if (dataCompletionRateBetween) {
            dataCompletionRateBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dataCompletionRate.between');
            })
        }
        if (dataCompletionRateNotBetween) {
            dataCompletionRateNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dataCompletionRate.not.between');
            })
        }
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }
        if (idNot !== undefined && idNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idNot, 'id.not');
        }
        if (idContains !== undefined && idContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idContains, 'id.contains');
        }
        if (idNotContains !== undefined && idNotContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idNotContains, 'id.not.contains');
        }
        if (idBeginsWith !== undefined && idBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idBeginsWith, 'id.beginsWith');
        }
        if (idNotBeginsWith !== undefined && idNotBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idNotBeginsWith, 'id.not.beginsWith');
        }
        if (idEndsWith !== undefined && idEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idEndsWith, 'id.endsWith');
        }
        if (idNotEndsWith !== undefined && idNotEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idNotEndsWith, 'id.not.endsWith');
        }
        if (pseudoidentifier !== undefined && pseudoidentifier !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifier, 'pseudoidentifier');
        }
        if (pseudoidentifierNot !== undefined && pseudoidentifierNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierNot, 'pseudoidentifier.not');
        }
        if (pseudoidentifierContains !== undefined && pseudoidentifierContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierContains, 'pseudoidentifier.contains');
        }
        if (pseudoidentifierNotContains !== undefined && pseudoidentifierNotContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierNotContains, 'pseudoidentifier.not.contains');
        }
        if (pseudoidentifierBeginsWith !== undefined && pseudoidentifierBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierBeginsWith, 'pseudoidentifier.beginsWith');
        }
        if (pseudoidentifierNotBeginsWith !== undefined && pseudoidentifierNotBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierNotBeginsWith, 'pseudoidentifier.not.beginsWith');
        }
        if (pseudoidentifierEndsWith !== undefined && pseudoidentifierEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierEndsWith, 'pseudoidentifier.endsWith');
        }
        if (pseudoidentifierNotEndsWith !== undefined && pseudoidentifierNotEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pseudoidentifierNotEndsWith, 'pseudoidentifier.not.endsWith');
        }
        if (clinicalCenter !== undefined && clinicalCenter !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenter, 'clinicalCenter');
        }
        if (clinicalCenterNot !== undefined && clinicalCenterNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterNot, 'clinicalCenter.not');
        }
        if (clinicalCenterContains !== undefined && clinicalCenterContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterContains, 'clinicalCenter.contains');
        }
        if (clinicalCenterNotContains !== undefined && clinicalCenterNotContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterNotContains, 'clinicalCenter.not.contains');
        }
        if (clinicalCenterBeginsWith !== undefined && clinicalCenterBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterBeginsWith, 'clinicalCenter.beginsWith');
        }
        if (clinicalCenterNotBeginsWith !== undefined && clinicalCenterNotBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterNotBeginsWith, 'clinicalCenter.not.beginsWith');
        }
        if (clinicalCenterEndsWith !== undefined && clinicalCenterEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterEndsWith, 'clinicalCenter.endsWith');
        }
        if (clinicalCenterNotEndsWith !== undefined && clinicalCenterNotEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalCenterNotEndsWith, 'clinicalCenter.not.endsWith');
        }
        if (clinicalIdentifier !== undefined && clinicalIdentifier !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifier, 'clinicalIdentifier');
        }
        if (clinicalIdentifierNot !== undefined && clinicalIdentifierNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierNot, 'clinicalIdentifier.not');
        }
        if (clinicalIdentifierContains !== undefined && clinicalIdentifierContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierContains, 'clinicalIdentifier.contains');
        }
        if (clinicalIdentifierNotContains !== undefined && clinicalIdentifierNotContains !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierNotContains, 'clinicalIdentifier.not.contains');
        }
        if (clinicalIdentifierBeginsWith !== undefined && clinicalIdentifierBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierBeginsWith, 'clinicalIdentifier.beginsWith');
        }
        if (clinicalIdentifierNotBeginsWith !== undefined && clinicalIdentifierNotBeginsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierNotBeginsWith, 'clinicalIdentifier.not.beginsWith');
        }
        if (clinicalIdentifierEndsWith !== undefined && clinicalIdentifierEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierEndsWith, 'clinicalIdentifier.endsWith');
        }
        if (clinicalIdentifierNotEndsWith !== undefined && clinicalIdentifierNotEndsWith !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clinicalIdentifierNotEndsWith, 'clinicalIdentifier.not.endsWith');
        }
        if (consentStatus !== undefined && consentStatus !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>consentStatus, 'consentStatus');
        }
        if (consentStatusNot !== undefined && consentStatusNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>consentStatusNot, 'consentStatus.not');
        }
        if (consentStatusAnyOf) {
            consentStatusAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'consentStatus.anyOf');
            })
        }
        if (gender !== undefined && gender !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>gender, 'gender');
        }
        if (genderNot !== undefined && genderNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderNot, 'gender.not');
        }
        if (genderAnyOf) {
            genderAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'gender.anyOf');
            })
        }
        if (genderNotAnyOf) {
            genderNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'gender.not.anyOf');
            })
        }
        if (genderDescendantsOf !== undefined && genderDescendantsOf !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderDescendantsOf, 'gender.descendantsOf');
        }
        if (raceNotExists !== undefined && raceNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raceNotExists, 'race.not.exists');
        }
        if (raceExists !== undefined && raceExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raceExists, 'race.exists');
        }
        if (race !== undefined && race !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>race, 'race');
        }
        if (raceNot !== undefined && raceNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raceNot, 'race.not');
        }
        if (raceAnyOf) {
            raceAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'race.anyOf');
            })
        }
        if (raceNotAnyOf) {
            raceNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'race.not.anyOf');
            })
        }
        if (raceDescendantsOf !== undefined && raceDescendantsOf !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>raceDescendantsOf, 'race.descendantsOf');
        }
        if (sexAtBirthNotExists !== undefined && sexAtBirthNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sexAtBirthNotExists, 'sexAtBirth.not.exists');
        }
        if (sexAtBirthExists !== undefined && sexAtBirthExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sexAtBirthExists, 'sexAtBirth.exists');
        }
        if (sexAtBirth !== undefined && sexAtBirth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sexAtBirth, 'sexAtBirth');
        }
        if (sexAtBirthNot !== undefined && sexAtBirthNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sexAtBirthNot, 'sexAtBirth.not');
        }
        if (sexAtBirthAnyOf) {
            sexAtBirthAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sexAtBirth.anyOf');
            })
        }
        if (sexAtBirthNotAnyOf) {
            sexAtBirthNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sexAtBirth.not.anyOf');
            })
        }
        if (sexAtBirthDescendantsOf !== undefined && sexAtBirthDescendantsOf !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sexAtBirthDescendantsOf, 'sexAtBirth.descendantsOf');
        }
        if (genderIdentityNotExists !== undefined && genderIdentityNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderIdentityNotExists, 'genderIdentity.not.exists');
        }
        if (genderIdentityExists !== undefined && genderIdentityExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderIdentityExists, 'genderIdentity.exists');
        }
        if (genderIdentity !== undefined && genderIdentity !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderIdentity, 'genderIdentity');
        }
        if (genderIdentityNot !== undefined && genderIdentityNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderIdentityNot, 'genderIdentity.not');
        }
        if (genderIdentityAnyOf) {
            genderIdentityAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'genderIdentity.anyOf');
            })
        }
        if (genderIdentityNotAnyOf) {
            genderIdentityNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'genderIdentity.not.anyOf');
            })
        }
        if (genderIdentityDescendantsOf !== undefined && genderIdentityDescendantsOf !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>genderIdentityDescendantsOf, 'genderIdentity.descendantsOf');
        }
        if (dateOfBirthBefore !== undefined && dateOfBirthBefore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthBefore, 'dateOfBirth.before');
        }
        if (dateOfBirthAfter !== undefined && dateOfBirthAfter !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthAfter, 'dateOfBirth.after');
        }
        if (dateOfBirthOnOrBefore !== undefined && dateOfBirthOnOrBefore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthOnOrBefore, 'dateOfBirth.onOrBefore');
        }
        if (dateOfBirthOnOrAfter !== undefined && dateOfBirthOnOrAfter !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthOnOrAfter, 'dateOfBirth.onOrAfter');
        }
        if (dateOfBirthOn !== undefined && dateOfBirthOn !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthOn, 'dateOfBirth.on');
        }
        if (dateOfBirthNotOn !== undefined && dateOfBirthNotOn !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfBirthNotOn, 'dateOfBirth.not.on');
        }
        if (dateOfBirthBetween) {
            dateOfBirthBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfBirth.between');
            })
        }
        if (dateOfBirthNotBetween) {
            dateOfBirthNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfBirth.not.between');
            })
        }
        if (isDeceased !== undefined && isDeceased !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>isDeceased, 'isDeceased');
        }
        if (dateOfDeathNotExists !== undefined && dateOfDeathNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathNotExists, 'dateOfDeath.not.exists');
        }
        if (dateOfDeathExists !== undefined && dateOfDeathExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathExists, 'dateOfDeath.exists');
        }
        if (dateOfDeathBefore !== undefined && dateOfDeathBefore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathBefore, 'dateOfDeath.before');
        }
        if (dateOfDeathAfter !== undefined && dateOfDeathAfter !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathAfter, 'dateOfDeath.after');
        }
        if (dateOfDeathOnOrBefore !== undefined && dateOfDeathOnOrBefore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathOnOrBefore, 'dateOfDeath.onOrBefore');
        }
        if (dateOfDeathOnOrAfter !== undefined && dateOfDeathOnOrAfter !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathOnOrAfter, 'dateOfDeath.onOrAfter');
        }
        if (dateOfDeathOn !== undefined && dateOfDeathOn !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathOn, 'dateOfDeath.on');
        }
        if (dateOfDeathNotOn !== undefined && dateOfDeathNotOn !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateOfDeathNotOn, 'dateOfDeath.not.on');
        }
        if (dateOfDeathBetween) {
            dateOfDeathBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfDeath.between');
            })
        }
        if (dateOfDeathNotBetween) {
            dateOfDeathNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfDeath.not.between');
            })
        }
        if (causeOfDeathNotExists !== undefined && causeOfDeathNotExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>causeOfDeathNotExists, 'causeOfDeath.not.exists');
        }
        if (causeOfDeathExists !== undefined && causeOfDeathExists !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>causeOfDeathExists, 'causeOfDeath.exists');
        }
        if (causeOfDeath !== undefined && causeOfDeath !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>causeOfDeath, 'causeOfDeath');
        }
        if (causeOfDeathNot !== undefined && causeOfDeathNot !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>causeOfDeathNot, 'causeOfDeath.not');
        }
        if (causeOfDeathAnyOf) {
            causeOfDeathAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'causeOfDeath.anyOf');
            })
        }
        if (causeOfDeathNotAnyOf) {
            causeOfDeathNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'causeOfDeath.not.anyOf');
            })
        }
        if (causeOfDeathDescendantsOf !== undefined && causeOfDeathDescendantsOf !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>causeOfDeathDescendantsOf, 'causeOfDeath.descendantsOf');
        }
        if (manager !== undefined && manager !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>manager, 'manager');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>offset, 'offset');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases`;
        return this.httpClient.request<PaginatedPatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResourceSchema>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResourceSchema>>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResourceSchema>>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling updatePatientCaseById.');
        }
        const patientCaseCreate = requestParameters?.patientCaseCreate;
        if (patientCaseCreate === null || patientCaseCreate === undefined) {
            throw new Error('Required parameter patientCaseCreate was null or undefined when calling updatePatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (JWTAuth) required
        localVarCredential = this.configuration.lookupCredential('JWTAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResourceSchema>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: patientCaseCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
