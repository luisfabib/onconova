/**
 * POP API
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { HistoryEventWithSchema } from '../model/history-event-with-schema';
// @ts-ignore
import { ModifiedResource } from '../model/modified-resource';
// @ts-ignore
import { PaginatedHistoryEventWithSchema } from '../model/paginated-history-event-with-schema';
// @ts-ignore
import { PaginatedPatientCase } from '../model/paginated-patient-case';
// @ts-ignore
import { PatientCase } from '../model/patient-case';
// @ts-ignore
import { PatientCaseCreate } from '../model/patient-case-create';
// @ts-ignore
import { PatientCaseDataCompletionStatusSchema } from '../model/patient-case-data-completion-status-schema';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';
import {
    PatientCasesServiceInterface,
    CreatePatientCaseRequestParams,
    CreatePatientCaseDataCompletionRequestParams,
    DeletePatientCaseByIdRequestParams,
    DeletePatientCaseDataCompletionRequestParams,
    GetAllPatientCaseHistoryEventsRequestParams,
    GetPatientCaseByIdRequestParams,
    GetPatientCaseByPseudoidentifierRequestParams,
    GetPatientCaseDataCompletionStatusRequestParams,
    GetPatientCaseHistoryEventByIdRequestParams,
    GetPatientCasesRequestParams,
    RevertPatientCaseToHistoryEventRequestParams,
    UpdatePatientCaseByIdRequestParams
} from './patient-cases.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class PatientCasesService extends BaseService implements PatientCasesServiceInterface {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public createPatientCase(requestParameters: CreatePatientCaseRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const patientCaseCreate = requestParameters?.patientCaseCreate;
        if (patientCaseCreate === null || patientCaseCreate === undefined) {
            throw new Error('Required parameter patientCaseCreate was null or undefined when calling createPatientCase.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases`;
        return this.httpClient.request<ModifiedResource>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: patientCaseCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Patient Case Data Completion
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public createPatientCaseDataCompletion(requestParameters: CreatePatientCaseDataCompletionRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling createPatientCaseDataCompletion.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling createPatientCaseDataCompletion.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResource>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deletePatientCaseById(requestParameters: DeletePatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling deletePatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Patient Case Data Completion
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deletePatientCaseDataCompletion(requestParameters: DeletePatientCaseDataCompletionRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling deletePatientCaseDataCompletion.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling deletePatientCaseDataCompletion.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Patient Case History Events
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllPatientCaseHistoryEvents(requestParameters: GetAllPatientCaseHistoryEventsRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedHistoryEventWithSchema>;
    public getAllPatientCaseHistoryEvents(requestParameters: GetAllPatientCaseHistoryEventsRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedHistoryEventWithSchema>>;
    public getAllPatientCaseHistoryEvents(requestParameters: GetAllPatientCaseHistoryEventsRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedHistoryEventWithSchema>>;
    public getAllPatientCaseHistoryEvents(requestParameters: GetAllPatientCaseHistoryEventsRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getAllPatientCaseHistoryEvents.');
        }
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events`;
        return this.httpClient.request<PaginatedHistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Default Clinical Center
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDefaultClinicalCenter(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;
    public getDefaultClinicalCenter(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;
    public getDefaultClinicalCenter(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;
    public getDefaultClinicalCenter(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/others/default-clinical-center`;
        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCase>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCase>>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCase>>;
    public getPatientCaseById(requestParameters: GetPatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case By Pseudoidentifier
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCase>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCase>>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCase>>;
    public getPatientCaseByPseudoidentifier(requestParameters: GetPatientCaseByPseudoidentifierRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const pseudoidentifier = requestParameters?.pseudoidentifier;
        if (pseudoidentifier === null || pseudoidentifier === undefined) {
            throw new Error('Required parameter pseudoidentifier was null or undefined when calling getPatientCaseByPseudoidentifier.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/pseudo/${this.configuration.encodeParam({name: "pseudoidentifier", value: pseudoidentifier, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case Data Completion Status
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PatientCaseDataCompletionStatusSchema>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PatientCaseDataCompletionStatusSchema>>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PatientCaseDataCompletionStatusSchema>>;
    public getPatientCaseDataCompletionStatus(requestParameters: GetPatientCaseDataCompletionStatusRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseDataCompletionStatus.');
        }
        const category = requestParameters?.category;
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getPatientCaseDataCompletionStatus.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-completion/${this.configuration.encodeParam({name: "category", value: category, in: "path", style: "simple", explode: false, dataType: "'comorbidities-assessments' | 'family-histories' | 'genomic-signatures' | 'genomic-variants' | 'lifestyles' | 'comorbidities' | 'neoplastic-entities' | 'performance-status' | 'radiotherapies' | 'risk-assessments' | 'stagings' | 'surgeries' | 'systemic-therapies' | 'tumor-markers' | 'vitals' | 'tumor-board-reviews' | 'adverse-events' | 'therapy-responses'", dataFormat: undefined})}`;
        return this.httpClient.request<PatientCaseDataCompletionStatusSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Patient Case History Event By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCaseHistoryEventById(requestParameters: GetPatientCaseHistoryEventByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HistoryEventWithSchema>;
    public getPatientCaseHistoryEventById(requestParameters: GetPatientCaseHistoryEventByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HistoryEventWithSchema>>;
    public getPatientCaseHistoryEventById(requestParameters: GetPatientCaseHistoryEventByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HistoryEventWithSchema>>;
    public getPatientCaseHistoryEventById(requestParameters: GetPatientCaseHistoryEventByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getPatientCaseHistoryEventById.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getPatientCaseHistoryEventById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<HistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Patient Cases Matching The Query
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedPatientCase>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedPatientCase>>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedPatientCase>>;
    public getPatientCases(requestParameters?: GetPatientCasesRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const ageLessThan = requestParameters?.ageLessThan;
        const ageLessThanOrEqual = requestParameters?.ageLessThanOrEqual;
        const ageGreaterThan = requestParameters?.ageGreaterThan;
        const ageGreaterThanOrEqual = requestParameters?.ageGreaterThanOrEqual;
        const ageEqual = requestParameters?.ageEqual;
        const ageNotEqual = requestParameters?.ageNotEqual;
        const ageBetween = requestParameters?.ageBetween;
        const ageNotBetween = requestParameters?.ageNotBetween;
        const overallSurvivalNotExists = requestParameters?.overallSurvivalNotExists;
        const overallSurvivalExists = requestParameters?.overallSurvivalExists;
        const overallSurvivalLessThan = requestParameters?.overallSurvivalLessThan;
        const overallSurvivalLessThanOrEqual = requestParameters?.overallSurvivalLessThanOrEqual;
        const overallSurvivalGreaterThan = requestParameters?.overallSurvivalGreaterThan;
        const overallSurvivalGreaterThanOrEqual = requestParameters?.overallSurvivalGreaterThanOrEqual;
        const overallSurvivalEqual = requestParameters?.overallSurvivalEqual;
        const overallSurvivalNotEqual = requestParameters?.overallSurvivalNotEqual;
        const overallSurvivalBetween = requestParameters?.overallSurvivalBetween;
        const overallSurvivalNotBetween = requestParameters?.overallSurvivalNotBetween;
        const ageAtDiagnosisNotExists = requestParameters?.ageAtDiagnosisNotExists;
        const ageAtDiagnosisExists = requestParameters?.ageAtDiagnosisExists;
        const ageAtDiagnosisLessThan = requestParameters?.ageAtDiagnosisLessThan;
        const ageAtDiagnosisLessThanOrEqual = requestParameters?.ageAtDiagnosisLessThanOrEqual;
        const ageAtDiagnosisGreaterThan = requestParameters?.ageAtDiagnosisGreaterThan;
        const ageAtDiagnosisGreaterThanOrEqual = requestParameters?.ageAtDiagnosisGreaterThanOrEqual;
        const ageAtDiagnosisEqual = requestParameters?.ageAtDiagnosisEqual;
        const ageAtDiagnosisNotEqual = requestParameters?.ageAtDiagnosisNotEqual;
        const ageAtDiagnosisBetween = requestParameters?.ageAtDiagnosisBetween;
        const ageAtDiagnosisNotBetween = requestParameters?.ageAtDiagnosisNotBetween;
        const dataCompletionRateLessThan = requestParameters?.dataCompletionRateLessThan;
        const dataCompletionRateLessThanOrEqual = requestParameters?.dataCompletionRateLessThanOrEqual;
        const dataCompletionRateGreaterThan = requestParameters?.dataCompletionRateGreaterThan;
        const dataCompletionRateGreaterThanOrEqual = requestParameters?.dataCompletionRateGreaterThanOrEqual;
        const dataCompletionRateEqual = requestParameters?.dataCompletionRateEqual;
        const dataCompletionRateNotEqual = requestParameters?.dataCompletionRateNotEqual;
        const dataCompletionRateBetween = requestParameters?.dataCompletionRateBetween;
        const dataCompletionRateNotBetween = requestParameters?.dataCompletionRateNotBetween;
        const id = requestParameters?.id;
        const idNot = requestParameters?.idNot;
        const idContains = requestParameters?.idContains;
        const idNotContains = requestParameters?.idNotContains;
        const idBeginsWith = requestParameters?.idBeginsWith;
        const idNotBeginsWith = requestParameters?.idNotBeginsWith;
        const idEndsWith = requestParameters?.idEndsWith;
        const idNotEndsWith = requestParameters?.idNotEndsWith;
        const pseudoidentifier = requestParameters?.pseudoidentifier;
        const pseudoidentifierNot = requestParameters?.pseudoidentifierNot;
        const pseudoidentifierContains = requestParameters?.pseudoidentifierContains;
        const pseudoidentifierNotContains = requestParameters?.pseudoidentifierNotContains;
        const pseudoidentifierBeginsWith = requestParameters?.pseudoidentifierBeginsWith;
        const pseudoidentifierNotBeginsWith = requestParameters?.pseudoidentifierNotBeginsWith;
        const pseudoidentifierEndsWith = requestParameters?.pseudoidentifierEndsWith;
        const pseudoidentifierNotEndsWith = requestParameters?.pseudoidentifierNotEndsWith;
        const clinicalCenter = requestParameters?.clinicalCenter;
        const clinicalCenterNot = requestParameters?.clinicalCenterNot;
        const clinicalCenterContains = requestParameters?.clinicalCenterContains;
        const clinicalCenterNotContains = requestParameters?.clinicalCenterNotContains;
        const clinicalCenterBeginsWith = requestParameters?.clinicalCenterBeginsWith;
        const clinicalCenterNotBeginsWith = requestParameters?.clinicalCenterNotBeginsWith;
        const clinicalCenterEndsWith = requestParameters?.clinicalCenterEndsWith;
        const clinicalCenterNotEndsWith = requestParameters?.clinicalCenterNotEndsWith;
        const clinicalIdentifier = requestParameters?.clinicalIdentifier;
        const clinicalIdentifierNot = requestParameters?.clinicalIdentifierNot;
        const clinicalIdentifierContains = requestParameters?.clinicalIdentifierContains;
        const clinicalIdentifierNotContains = requestParameters?.clinicalIdentifierNotContains;
        const clinicalIdentifierBeginsWith = requestParameters?.clinicalIdentifierBeginsWith;
        const clinicalIdentifierNotBeginsWith = requestParameters?.clinicalIdentifierNotBeginsWith;
        const clinicalIdentifierEndsWith = requestParameters?.clinicalIdentifierEndsWith;
        const clinicalIdentifierNotEndsWith = requestParameters?.clinicalIdentifierNotEndsWith;
        const consentStatus = requestParameters?.consentStatus;
        const consentStatusNot = requestParameters?.consentStatusNot;
        const consentStatusAnyOf = requestParameters?.consentStatusAnyOf;
        const gender = requestParameters?.gender;
        const genderNot = requestParameters?.genderNot;
        const genderAnyOf = requestParameters?.genderAnyOf;
        const genderNotAnyOf = requestParameters?.genderNotAnyOf;
        const genderDescendantsOf = requestParameters?.genderDescendantsOf;
        const raceNotExists = requestParameters?.raceNotExists;
        const raceExists = requestParameters?.raceExists;
        const race = requestParameters?.race;
        const raceNot = requestParameters?.raceNot;
        const raceAnyOf = requestParameters?.raceAnyOf;
        const raceNotAnyOf = requestParameters?.raceNotAnyOf;
        const raceDescendantsOf = requestParameters?.raceDescendantsOf;
        const sexAtBirthNotExists = requestParameters?.sexAtBirthNotExists;
        const sexAtBirthExists = requestParameters?.sexAtBirthExists;
        const sexAtBirth = requestParameters?.sexAtBirth;
        const sexAtBirthNot = requestParameters?.sexAtBirthNot;
        const sexAtBirthAnyOf = requestParameters?.sexAtBirthAnyOf;
        const sexAtBirthNotAnyOf = requestParameters?.sexAtBirthNotAnyOf;
        const sexAtBirthDescendantsOf = requestParameters?.sexAtBirthDescendantsOf;
        const genderIdentityNotExists = requestParameters?.genderIdentityNotExists;
        const genderIdentityExists = requestParameters?.genderIdentityExists;
        const genderIdentity = requestParameters?.genderIdentity;
        const genderIdentityNot = requestParameters?.genderIdentityNot;
        const genderIdentityAnyOf = requestParameters?.genderIdentityAnyOf;
        const genderIdentityNotAnyOf = requestParameters?.genderIdentityNotAnyOf;
        const genderIdentityDescendantsOf = requestParameters?.genderIdentityDescendantsOf;
        const dateOfBirthBefore = requestParameters?.dateOfBirthBefore;
        const dateOfBirthAfter = requestParameters?.dateOfBirthAfter;
        const dateOfBirthOnOrBefore = requestParameters?.dateOfBirthOnOrBefore;
        const dateOfBirthOnOrAfter = requestParameters?.dateOfBirthOnOrAfter;
        const dateOfBirthOn = requestParameters?.dateOfBirthOn;
        const dateOfBirthNotOn = requestParameters?.dateOfBirthNotOn;
        const dateOfBirthBetween = requestParameters?.dateOfBirthBetween;
        const dateOfBirthNotBetween = requestParameters?.dateOfBirthNotBetween;
        const isDeceased = requestParameters?.isDeceased;
        const dateOfDeathNotExists = requestParameters?.dateOfDeathNotExists;
        const dateOfDeathExists = requestParameters?.dateOfDeathExists;
        const dateOfDeathBefore = requestParameters?.dateOfDeathBefore;
        const dateOfDeathAfter = requestParameters?.dateOfDeathAfter;
        const dateOfDeathOnOrBefore = requestParameters?.dateOfDeathOnOrBefore;
        const dateOfDeathOnOrAfter = requestParameters?.dateOfDeathOnOrAfter;
        const dateOfDeathOn = requestParameters?.dateOfDeathOn;
        const dateOfDeathNotOn = requestParameters?.dateOfDeathNotOn;
        const dateOfDeathBetween = requestParameters?.dateOfDeathBetween;
        const dateOfDeathNotBetween = requestParameters?.dateOfDeathNotBetween;
        const causeOfDeathNotExists = requestParameters?.causeOfDeathNotExists;
        const causeOfDeathExists = requestParameters?.causeOfDeathExists;
        const causeOfDeath = requestParameters?.causeOfDeath;
        const causeOfDeathNot = requestParameters?.causeOfDeathNot;
        const causeOfDeathAnyOf = requestParameters?.causeOfDeathAnyOf;
        const causeOfDeathNotAnyOf = requestParameters?.causeOfDeathNotAnyOf;
        const causeOfDeathDescendantsOf = requestParameters?.causeOfDeathDescendantsOf;
        const manager = requestParameters?.manager;
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageLessThan, 'age.lessThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageLessThanOrEqual, 'age.lessThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageGreaterThan, 'age.greaterThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageGreaterThanOrEqual, 'age.greaterThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageEqual, 'age.equal');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageNotEqual, 'age.not.equal');
        if (ageBetween) {
            ageBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'age.between');
            })
        }
        if (ageNotBetween) {
            ageNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'age.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalNotExists, 'overallSurvival.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalExists, 'overallSurvival.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalLessThan, 'overallSurvival.lessThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalLessThanOrEqual, 'overallSurvival.lessThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalGreaterThan, 'overallSurvival.greaterThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalGreaterThanOrEqual, 'overallSurvival.greaterThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalEqual, 'overallSurvival.equal');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>overallSurvivalNotEqual, 'overallSurvival.not.equal');
        if (overallSurvivalBetween) {
            overallSurvivalBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'overallSurvival.between');
            })
        }
        if (overallSurvivalNotBetween) {
            overallSurvivalNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'overallSurvival.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisNotExists, 'ageAtDiagnosis.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisExists, 'ageAtDiagnosis.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisLessThan, 'ageAtDiagnosis.lessThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisLessThanOrEqual, 'ageAtDiagnosis.lessThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisGreaterThan, 'ageAtDiagnosis.greaterThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisGreaterThanOrEqual, 'ageAtDiagnosis.greaterThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisEqual, 'ageAtDiagnosis.equal');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ageAtDiagnosisNotEqual, 'ageAtDiagnosis.not.equal');
        if (ageAtDiagnosisBetween) {
            ageAtDiagnosisBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ageAtDiagnosis.between');
            })
        }
        if (ageAtDiagnosisNotBetween) {
            ageAtDiagnosisNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ageAtDiagnosis.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateLessThan, 'dataCompletionRate.lessThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateLessThanOrEqual, 'dataCompletionRate.lessThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateGreaterThan, 'dataCompletionRate.greaterThan');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateGreaterThanOrEqual, 'dataCompletionRate.greaterThanOrEqual');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateEqual, 'dataCompletionRate.equal');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dataCompletionRateNotEqual, 'dataCompletionRate.not.equal');
        if (dataCompletionRateBetween) {
            dataCompletionRateBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dataCompletionRate.between');
            })
        }
        if (dataCompletionRateNotBetween) {
            dataCompletionRateNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dataCompletionRate.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>id, 'id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNot, 'id.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idContains, 'id.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotContains, 'id.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idBeginsWith, 'id.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotBeginsWith, 'id.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idEndsWith, 'id.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotEndsWith, 'id.not.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifier, 'pseudoidentifier');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierNot, 'pseudoidentifier.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierContains, 'pseudoidentifier.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierNotContains, 'pseudoidentifier.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierBeginsWith, 'pseudoidentifier.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierNotBeginsWith, 'pseudoidentifier.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierEndsWith, 'pseudoidentifier.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>pseudoidentifierNotEndsWith, 'pseudoidentifier.not.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenter, 'clinicalCenter');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterNot, 'clinicalCenter.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterContains, 'clinicalCenter.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterNotContains, 'clinicalCenter.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterBeginsWith, 'clinicalCenter.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterNotBeginsWith, 'clinicalCenter.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterEndsWith, 'clinicalCenter.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenterNotEndsWith, 'clinicalCenter.not.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifier, 'clinicalIdentifier');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierNot, 'clinicalIdentifier.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierContains, 'clinicalIdentifier.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierNotContains, 'clinicalIdentifier.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierBeginsWith, 'clinicalIdentifier.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierNotBeginsWith, 'clinicalIdentifier.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierEndsWith, 'clinicalIdentifier.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalIdentifierNotEndsWith, 'clinicalIdentifier.not.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>consentStatus, 'consentStatus');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>consentStatusNot, 'consentStatus.not');
        if (consentStatusAnyOf) {
            consentStatusAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'consentStatus.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>gender, 'gender');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderNot, 'gender.not');
        if (genderAnyOf) {
            genderAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'gender.anyOf');
            })
        }
        if (genderNotAnyOf) {
            genderNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'gender.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderDescendantsOf, 'gender.descendantsOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>raceNotExists, 'race.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>raceExists, 'race.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>race, 'race');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>raceNot, 'race.not');
        if (raceAnyOf) {
            raceAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'race.anyOf');
            })
        }
        if (raceNotAnyOf) {
            raceNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'race.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>raceDescendantsOf, 'race.descendantsOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>sexAtBirthNotExists, 'sexAtBirth.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>sexAtBirthExists, 'sexAtBirth.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>sexAtBirth, 'sexAtBirth');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>sexAtBirthNot, 'sexAtBirth.not');
        if (sexAtBirthAnyOf) {
            sexAtBirthAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sexAtBirth.anyOf');
            })
        }
        if (sexAtBirthNotAnyOf) {
            sexAtBirthNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sexAtBirth.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>sexAtBirthDescendantsOf, 'sexAtBirth.descendantsOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderIdentityNotExists, 'genderIdentity.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderIdentityExists, 'genderIdentity.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderIdentity, 'genderIdentity');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderIdentityNot, 'genderIdentity.not');
        if (genderIdentityAnyOf) {
            genderIdentityAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'genderIdentity.anyOf');
            })
        }
        if (genderIdentityNotAnyOf) {
            genderIdentityNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'genderIdentity.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>genderIdentityDescendantsOf, 'genderIdentity.descendantsOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthBefore, 'dateOfBirth.before');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthAfter, 'dateOfBirth.after');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthOnOrBefore, 'dateOfBirth.onOrBefore');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthOnOrAfter, 'dateOfBirth.onOrAfter');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthOn, 'dateOfBirth.on');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfBirthNotOn, 'dateOfBirth.not.on');
        if (dateOfBirthBetween) {
            dateOfBirthBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfBirth.between');
            })
        }
        if (dateOfBirthNotBetween) {
            dateOfBirthNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfBirth.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>isDeceased, 'isDeceased');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathNotExists, 'dateOfDeath.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathExists, 'dateOfDeath.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathBefore, 'dateOfDeath.before');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathAfter, 'dateOfDeath.after');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathOnOrBefore, 'dateOfDeath.onOrBefore');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathOnOrAfter, 'dateOfDeath.onOrAfter');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathOn, 'dateOfDeath.on');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>dateOfDeathNotOn, 'dateOfDeath.not.on');
        if (dateOfDeathBetween) {
            dateOfDeathBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfDeath.between');
            })
        }
        if (dateOfDeathNotBetween) {
            dateOfDeathNotBetween.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'dateOfDeath.not.between');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>causeOfDeathNotExists, 'causeOfDeath.not.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>causeOfDeathExists, 'causeOfDeath.exists');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>causeOfDeath, 'causeOfDeath');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>causeOfDeathNot, 'causeOfDeath.not');
        if (causeOfDeathAnyOf) {
            causeOfDeathAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'causeOfDeath.anyOf');
            })
        }
        if (causeOfDeathNotAnyOf) {
            causeOfDeathNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'causeOfDeath.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>causeOfDeathDescendantsOf, 'causeOfDeath.descendantsOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>manager, 'manager');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases`;
        return this.httpClient.request<PaginatedPatientCase>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revert Patient Case To History Event
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revertPatientCaseToHistoryEvent(requestParameters: RevertPatientCaseToHistoryEventRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public revertPatientCaseToHistoryEvent(requestParameters: RevertPatientCaseToHistoryEventRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public revertPatientCaseToHistoryEvent(requestParameters: RevertPatientCaseToHistoryEventRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public revertPatientCaseToHistoryEvent(requestParameters: RevertPatientCaseToHistoryEventRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling revertPatientCaseToHistoryEvent.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling revertPatientCaseToHistoryEvent.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/reversion`;
        return this.httpClient.request<ModifiedResource>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Patient Case
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public updatePatientCaseById(requestParameters: UpdatePatientCaseByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const caseId = requestParameters?.caseId;
        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling updatePatientCaseById.');
        }
        const patientCaseCreate = requestParameters?.patientCaseCreate;
        if (patientCaseCreate === null || patientCaseCreate === undefined) {
            throw new Error('Required parameter patientCaseCreate was null or undefined when calling updatePatientCaseById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (JWTAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('JWTAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/patient-cases/${this.configuration.encodeParam({name: "caseId", value: caseId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResource>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: patientCaseCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
