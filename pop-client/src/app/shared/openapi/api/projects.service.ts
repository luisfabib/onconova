/**
 * POP API
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { HistoryEventWithSchema } from '../model/history-event-with-schema';
// @ts-ignore
import { ModifiedResource } from '../model/modified-resource';
// @ts-ignore
import { PaginatedHistoryEventWithSchema } from '../model/paginated-history-event-with-schema';
// @ts-ignore
import { PaginatedProject } from '../model/paginated-project';
// @ts-ignore
import { PaginatedProjectDataManagerGrant } from '../model/paginated-project-data-manager-grant';
// @ts-ignore
import { Project } from '../model/project';
// @ts-ignore
import { ProjectCreate } from '../model/project-create';
// @ts-ignore
import { ProjectDataManagerGrant } from '../model/project-data-manager-grant';
// @ts-ignore
import { ProjectDataManagerGrantCreate } from '../model/project-data-manager-grant-create';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';
import {
    ProjectsServiceInterface,
    CreateProjectRequestParams,
    CreateProjectDataManagerGrantRequestParams,
    DeleteProjectByIdRequestParams,
    GetAllProjectDataManagementGrantHistoryEventsRequestParams,
    GetAllProjectHistoryEventsRequestParams,
    GetProjectByIdRequestParams,
    GetProjectDataManagementGrantHistoryEventByIdRequestParams,
    GetProjectDataManagerGrantRequestParams,
    GetProjectDataManagerGrantByIdRequestParams,
    GetProjectHistoryEventByIdRequestParams,
    GetProjectsRequestParams,
    RevertProjectDataManagementGrantToHistoryEventRequestParams,
    RevertProjectToHistoryEventRequestParams,
    RevokeProjectDataManagerGrantRequestParams,
    UpdateProjectByIdRequestParams
} from './projects.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class ProjectsService extends BaseService implements ProjectsServiceInterface {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Project
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProject(requestParameters: CreateProjectRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public createProject(requestParameters: CreateProjectRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public createProject(requestParameters: CreateProjectRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public createProject(requestParameters: CreateProjectRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectCreate = requestParameters?.projectCreate;
        if (projectCreate === null || projectCreate === undefined) {
            throw new Error('Required parameter projectCreate was null or undefined when calling createProject.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects`;
        return this.httpClient.request<ModifiedResource>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: projectCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Project Data Manager Grant
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProjectDataManagerGrant(requestParameters: CreateProjectDataManagerGrantRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public createProjectDataManagerGrant(requestParameters: CreateProjectDataManagerGrantRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public createProjectDataManagerGrant(requestParameters: CreateProjectDataManagerGrantRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public createProjectDataManagerGrant(requestParameters: CreateProjectDataManagerGrantRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createProjectDataManagerGrant.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling createProjectDataManagerGrant.');
        }
        const projectDataManagerGrantCreate = requestParameters?.projectDataManagerGrantCreate;
        if (projectDataManagerGrantCreate === null || projectDataManagerGrantCreate === undefined) {
            throw new Error('Required parameter projectDataManagerGrantCreate was null or undefined when calling createProjectDataManagerGrant.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants`;
        return this.httpClient.request<ModifiedResource>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: projectDataManagerGrantCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Project
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProjectById(requestParameters: DeleteProjectByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public deleteProjectById(requestParameters: DeleteProjectByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public deleteProjectById(requestParameters: DeleteProjectByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public deleteProjectById(requestParameters: DeleteProjectByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProjectById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Project Data Management Grant History Events
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllProjectDataManagementGrantHistoryEvents(requestParameters: GetAllProjectDataManagementGrantHistoryEventsRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedHistoryEventWithSchema>;
    public getAllProjectDataManagementGrantHistoryEvents(requestParameters: GetAllProjectDataManagementGrantHistoryEventsRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedHistoryEventWithSchema>>;
    public getAllProjectDataManagementGrantHistoryEvents(requestParameters: GetAllProjectDataManagementGrantHistoryEventsRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedHistoryEventWithSchema>>;
    public getAllProjectDataManagementGrantHistoryEvents(requestParameters: GetAllProjectDataManagementGrantHistoryEventsRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAllProjectDataManagementGrantHistoryEvents.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getAllProjectDataManagementGrantHistoryEvents.');
        }
        const grantId = requestParameters?.grantId;
        if (grantId === null || grantId === undefined) {
            throw new Error('Required parameter grantId was null or undefined when calling getAllProjectDataManagementGrantHistoryEvents.');
        }
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants/${this.configuration.encodeParam({name: "grantId", value: grantId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events`;
        return this.httpClient.request<PaginatedHistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Project History Events
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllProjectHistoryEvents(requestParameters: GetAllProjectHistoryEventsRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedHistoryEventWithSchema>;
    public getAllProjectHistoryEvents(requestParameters: GetAllProjectHistoryEventsRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedHistoryEventWithSchema>>;
    public getAllProjectHistoryEvents(requestParameters: GetAllProjectHistoryEventsRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedHistoryEventWithSchema>>;
    public getAllProjectHistoryEvents(requestParameters: GetAllProjectHistoryEventsRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAllProjectHistoryEvents.');
        }
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events`;
        return this.httpClient.request<PaginatedHistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Project By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectById(requestParameters: GetProjectByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<Project>;
    public getProjectById(requestParameters: GetProjectByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Project>>;
    public getProjectById(requestParameters: GetProjectByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Project>>;
    public getProjectById(requestParameters: GetProjectByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<Project>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Project Data Management Grant History Event By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectDataManagementGrantHistoryEventById(requestParameters: GetProjectDataManagementGrantHistoryEventByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HistoryEventWithSchema>;
    public getProjectDataManagementGrantHistoryEventById(requestParameters: GetProjectDataManagementGrantHistoryEventByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HistoryEventWithSchema>>;
    public getProjectDataManagementGrantHistoryEventById(requestParameters: GetProjectDataManagementGrantHistoryEventByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HistoryEventWithSchema>>;
    public getProjectDataManagementGrantHistoryEventById(requestParameters: GetProjectDataManagementGrantHistoryEventByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectDataManagementGrantHistoryEventById.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getProjectDataManagementGrantHistoryEventById.');
        }
        const grantId = requestParameters?.grantId;
        if (grantId === null || grantId === undefined) {
            throw new Error('Required parameter grantId was null or undefined when calling getProjectDataManagementGrantHistoryEventById.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getProjectDataManagementGrantHistoryEventById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants/${this.configuration.encodeParam({name: "grantId", value: grantId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<HistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Project Data Manager Grant
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectDataManagerGrant(requestParameters: GetProjectDataManagerGrantRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedProjectDataManagerGrant>;
    public getProjectDataManagerGrant(requestParameters: GetProjectDataManagerGrantRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedProjectDataManagerGrant>>;
    public getProjectDataManagerGrant(requestParameters: GetProjectDataManagerGrantRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedProjectDataManagerGrant>>;
    public getProjectDataManagerGrant(requestParameters: GetProjectDataManagerGrantRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectDataManagerGrant.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getProjectDataManagerGrant.');
        }
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants`;
        return this.httpClient.request<PaginatedProjectDataManagerGrant>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check Project Data Manager Grant
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectDataManagerGrantById(requestParameters: GetProjectDataManagerGrantByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ProjectDataManagerGrant>;
    public getProjectDataManagerGrantById(requestParameters: GetProjectDataManagerGrantByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ProjectDataManagerGrant>>;
    public getProjectDataManagerGrantById(requestParameters: GetProjectDataManagerGrantByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ProjectDataManagerGrant>>;
    public getProjectDataManagerGrantById(requestParameters: GetProjectDataManagerGrantByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectDataManagerGrantById.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getProjectDataManagerGrantById.');
        }
        const grantId = requestParameters?.grantId;
        if (grantId === null || grantId === undefined) {
            throw new Error('Required parameter grantId was null or undefined when calling getProjectDataManagerGrantById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants/${this.configuration.encodeParam({name: "grantId", value: grantId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ProjectDataManagerGrant>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Project History Event By Id
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectHistoryEventById(requestParameters: GetProjectHistoryEventByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HistoryEventWithSchema>;
    public getProjectHistoryEventById(requestParameters: GetProjectHistoryEventByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HistoryEventWithSchema>>;
    public getProjectHistoryEventById(requestParameters: GetProjectHistoryEventByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HistoryEventWithSchema>>;
    public getProjectHistoryEventById(requestParameters: GetProjectHistoryEventByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectHistoryEventById.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getProjectHistoryEventById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<HistoryEventWithSchema>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get All Projects Matching The Query
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjects(requestParameters?: GetProjectsRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<PaginatedProject>;
    public getProjects(requestParameters?: GetProjectsRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<PaginatedProject>>;
    public getProjects(requestParameters?: GetProjectsRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<PaginatedProject>>;
    public getProjects(requestParameters?: GetProjectsRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const id = requestParameters?.id;
        const idNot = requestParameters?.idNot;
        const idContains = requestParameters?.idContains;
        const idNotContains = requestParameters?.idNotContains;
        const idBeginsWith = requestParameters?.idBeginsWith;
        const idNotBeginsWith = requestParameters?.idNotBeginsWith;
        const idEndsWith = requestParameters?.idEndsWith;
        const idNotEndsWith = requestParameters?.idNotEndsWith;
        const idAnyOf = requestParameters?.idAnyOf;
        const idNotAnyOf = requestParameters?.idNotAnyOf;
        const leaderUsername = requestParameters?.leaderUsername;
        const leaderUsernameNot = requestParameters?.leaderUsernameNot;
        const leaderUsernameAnyOf = requestParameters?.leaderUsernameAnyOf;
        const leaderUsernameNotAnyOf = requestParameters?.leaderUsernameNotAnyOf;
        const clinicalCenters = requestParameters?.clinicalCenters;
        const clinicalCentersNot = requestParameters?.clinicalCentersNot;
        const clinicalCentersContains = requestParameters?.clinicalCentersContains;
        const clinicalCentersNotContains = requestParameters?.clinicalCentersNotContains;
        const clinicalCentersBeginsWith = requestParameters?.clinicalCentersBeginsWith;
        const clinicalCentersNotBeginsWith = requestParameters?.clinicalCentersNotBeginsWith;
        const clinicalCentersEndsWith = requestParameters?.clinicalCentersEndsWith;
        const clinicalCentersNotEndsWith = requestParameters?.clinicalCentersNotEndsWith;
        const clinicalCentersAnyOf = requestParameters?.clinicalCentersAnyOf;
        const clinicalCentersNotAnyOf = requestParameters?.clinicalCentersNotAnyOf;
        const title = requestParameters?.title;
        const titleNot = requestParameters?.titleNot;
        const titleContains = requestParameters?.titleContains;
        const titleNotContains = requestParameters?.titleNotContains;
        const titleBeginsWith = requestParameters?.titleBeginsWith;
        const titleNotBeginsWith = requestParameters?.titleNotBeginsWith;
        const titleEndsWith = requestParameters?.titleEndsWith;
        const titleNotEndsWith = requestParameters?.titleNotEndsWith;
        const titleAnyOf = requestParameters?.titleAnyOf;
        const titleNotAnyOf = requestParameters?.titleNotAnyOf;
        const summary = requestParameters?.summary;
        const summaryNot = requestParameters?.summaryNot;
        const summaryContains = requestParameters?.summaryContains;
        const summaryNotContains = requestParameters?.summaryNotContains;
        const summaryBeginsWith = requestParameters?.summaryBeginsWith;
        const summaryNotBeginsWith = requestParameters?.summaryNotBeginsWith;
        const summaryEndsWith = requestParameters?.summaryEndsWith;
        const summaryNotEndsWith = requestParameters?.summaryNotEndsWith;
        const summaryAnyOf = requestParameters?.summaryAnyOf;
        const summaryNotAnyOf = requestParameters?.summaryNotAnyOf;
        const ethicsApprovalNumber = requestParameters?.ethicsApprovalNumber;
        const ethicsApprovalNumberNot = requestParameters?.ethicsApprovalNumberNot;
        const ethicsApprovalNumberContains = requestParameters?.ethicsApprovalNumberContains;
        const ethicsApprovalNumberNotContains = requestParameters?.ethicsApprovalNumberNotContains;
        const ethicsApprovalNumberBeginsWith = requestParameters?.ethicsApprovalNumberBeginsWith;
        const ethicsApprovalNumberNotBeginsWith = requestParameters?.ethicsApprovalNumberNotBeginsWith;
        const ethicsApprovalNumberEndsWith = requestParameters?.ethicsApprovalNumberEndsWith;
        const ethicsApprovalNumberNotEndsWith = requestParameters?.ethicsApprovalNumberNotEndsWith;
        const ethicsApprovalNumberAnyOf = requestParameters?.ethicsApprovalNumberAnyOf;
        const ethicsApprovalNumberNotAnyOf = requestParameters?.ethicsApprovalNumberNotAnyOf;
        const status = requestParameters?.status;
        const statusNot = requestParameters?.statusNot;
        const statusAnyOf = requestParameters?.statusAnyOf;
        const membersUsername = requestParameters?.membersUsername;
        const membersUsernameNot = requestParameters?.membersUsernameNot;
        const membersUsernameAnyOf = requestParameters?.membersUsernameAnyOf;
        const membersUsernameNotAnyOf = requestParameters?.membersUsernameNotAnyOf;
        const limit = requestParameters?.limit;
        const offset = requestParameters?.offset;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>id, 'id');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNot, 'id.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idContains, 'id.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotContains, 'id.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idBeginsWith, 'id.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotBeginsWith, 'id.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idEndsWith, 'id.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>idNotEndsWith, 'id.not.endsWith');
        if (idAnyOf) {
            idAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'id.anyOf');
            })
        }
        if (idNotAnyOf) {
            idNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'id.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>leaderUsername, 'leader.username');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>leaderUsernameNot, 'leader.username.not');
        if (leaderUsernameAnyOf) {
            leaderUsernameAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'leader.username.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>leaderUsernameNotAnyOf, 'leader.username.not.anyOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCenters, 'clinicalCenters');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersNot, 'clinicalCenters.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersContains, 'clinicalCenters.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersNotContains, 'clinicalCenters.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersBeginsWith, 'clinicalCenters.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersNotBeginsWith, 'clinicalCenters.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersEndsWith, 'clinicalCenters.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>clinicalCentersNotEndsWith, 'clinicalCenters.not.endsWith');
        if (clinicalCentersAnyOf) {
            clinicalCentersAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'clinicalCenters.anyOf');
            })
        }
        if (clinicalCentersNotAnyOf) {
            clinicalCentersNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'clinicalCenters.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>title, 'title');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleNot, 'title.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleContains, 'title.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleNotContains, 'title.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleBeginsWith, 'title.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleNotBeginsWith, 'title.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleEndsWith, 'title.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>titleNotEndsWith, 'title.not.endsWith');
        if (titleAnyOf) {
            titleAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'title.anyOf');
            })
        }
        if (titleNotAnyOf) {
            titleNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'title.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summary, 'summary');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryNot, 'summary.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryContains, 'summary.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryNotContains, 'summary.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryBeginsWith, 'summary.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryNotBeginsWith, 'summary.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryEndsWith, 'summary.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>summaryNotEndsWith, 'summary.not.endsWith');
        if (summaryAnyOf) {
            summaryAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'summary.anyOf');
            })
        }
        if (summaryNotAnyOf) {
            summaryNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'summary.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumber, 'ethicsApprovalNumber');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberNot, 'ethicsApprovalNumber.not');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberContains, 'ethicsApprovalNumber.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberNotContains, 'ethicsApprovalNumber.not.contains');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberBeginsWith, 'ethicsApprovalNumber.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberNotBeginsWith, 'ethicsApprovalNumber.not.beginsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberEndsWith, 'ethicsApprovalNumber.endsWith');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>ethicsApprovalNumberNotEndsWith, 'ethicsApprovalNumber.not.endsWith');
        if (ethicsApprovalNumberAnyOf) {
            ethicsApprovalNumberAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ethicsApprovalNumber.anyOf');
            })
        }
        if (ethicsApprovalNumberNotAnyOf) {
            ethicsApprovalNumberNotAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ethicsApprovalNumber.not.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>status, 'status');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>statusNot, 'status.not');
        if (statusAnyOf) {
            statusAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>membersUsername, 'members.username');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>membersUsernameNot, 'members.username.not');
        if (membersUsernameAnyOf) {
            membersUsernameAnyOf.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'members.username.anyOf');
            })
        }
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>membersUsernameNotAnyOf, 'members.username.not.anyOf');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>offset, 'offset');

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects`;
        return this.httpClient.request<PaginatedProject>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revert Project Data Management Grant To History Event
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revertProjectDataManagementGrantToHistoryEvent(requestParameters: RevertProjectDataManagementGrantToHistoryEventRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public revertProjectDataManagementGrantToHistoryEvent(requestParameters: RevertProjectDataManagementGrantToHistoryEventRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public revertProjectDataManagementGrantToHistoryEvent(requestParameters: RevertProjectDataManagementGrantToHistoryEventRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public revertProjectDataManagementGrantToHistoryEvent(requestParameters: RevertProjectDataManagementGrantToHistoryEventRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling revertProjectDataManagementGrantToHistoryEvent.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling revertProjectDataManagementGrantToHistoryEvent.');
        }
        const grantId = requestParameters?.grantId;
        if (grantId === null || grantId === undefined) {
            throw new Error('Required parameter grantId was null or undefined when calling revertProjectDataManagementGrantToHistoryEvent.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling revertProjectDataManagementGrantToHistoryEvent.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants/${this.configuration.encodeParam({name: "grantId", value: grantId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/reversion`;
        return this.httpClient.request<ModifiedResource>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revert Project To History Event
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revertProjectToHistoryEvent(requestParameters: RevertProjectToHistoryEventRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public revertProjectToHistoryEvent(requestParameters: RevertProjectToHistoryEventRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public revertProjectToHistoryEvent(requestParameters: RevertProjectToHistoryEventRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public revertProjectToHistoryEvent(requestParameters: RevertProjectToHistoryEventRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling revertProjectToHistoryEvent.');
        }
        const eventId = requestParameters?.eventId;
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling revertProjectToHistoryEvent.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/history/events/${this.configuration.encodeParam({name: "eventId", value: eventId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/reversion`;
        return this.httpClient.request<ModifiedResource>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revoke Project Data Manager Grant
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeProjectDataManagerGrant(requestParameters: RevokeProjectDataManagerGrantRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public revokeProjectDataManagerGrant(requestParameters: RevokeProjectDataManagerGrantRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public revokeProjectDataManagerGrant(requestParameters: RevokeProjectDataManagerGrantRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public revokeProjectDataManagerGrant(requestParameters: RevokeProjectDataManagerGrantRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling revokeProjectDataManagerGrant.');
        }
        const memberId = requestParameters?.memberId;
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling revokeProjectDataManagerGrant.');
        }
        const grantId = requestParameters?.grantId;
        if (grantId === null || grantId === undefined) {
            throw new Error('Required parameter grantId was null or undefined when calling revokeProjectDataManagerGrant.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/members/${this.configuration.encodeParam({name: "memberId", value: memberId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/data-management/grants/${this.configuration.encodeParam({name: "grantId", value: grantId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResource>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Project
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProjectById(requestParameters: UpdateProjectByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ModifiedResource>;
    public updateProjectById(requestParameters: UpdateProjectByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ModifiedResource>>;
    public updateProjectById(requestParameters: UpdateProjectByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ModifiedResource>>;
    public updateProjectById(requestParameters: UpdateProjectByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        const projectId = requestParameters?.projectId;
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProjectById.');
        }
        const projectCreate = requestParameters?.projectCreate;
        if (projectCreate === null || projectCreate === undefined) {
            throw new Error('Required parameter projectCreate was null or undefined when calling updateProjectById.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (XSessionTokenAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('XSessionTokenAuth', 'X-SESSION-TOKEN', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/projects/${this.configuration.encodeParam({name: "projectId", value: projectId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<ModifiedResource>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: projectCreate,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
